name: Gmail to LINE Notification

on:
  schedule:
    # ÊØéÊôÇ0ÂàÜ„Å´ÂÆüË°å
    - cron: '0 * * * *'
  workflow_dispatch:

jobs:
  notify:
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client requests

      - name: Check Gmail and notify to LINE
        id: gmail_check
        env:
          GOOGLE_CREDENTIALS: ${{ secrets.GOOGLE_CREDENTIALS }}
          LINE_CHANNEL_ACCESS_TOKEN: ${{ secrets.LINE_CHANNEL_ACCESS_TOKEN }}
          LINE_USER_ID: ${{ secrets.LINE_USER_ID }}
        run: |
          python << 'EOF'
          import os
          import json
          import base64
          from google.oauth2 import service_account
          from googleapiclient.discovery import build
          import requests

          def get_gmail_service():
              creds_info = json.loads(os.environ['GOOGLE_CREDENTIALS'])
              credentials = service_account.Credentials.from_service_account_info(
                  creds_info,
                  scopes=['https://www.googleapis.com/auth/gmail.readonly']
              )
              return build('gmail', 'v1', credentials=credentials)

          def get_unread_fts_emails(service, user_id='me'):
              try:
                  query = 'label:fts is:unread'
                  results = service.users().messages().list(
                      userId=user_id,
                      q=query,
                      maxResults=1
                  ).execute()

                  messages = results.get('messages', [])
                  if not messages:
                      print("No unread emails with 'fts' label found.")
                      return None

                  # ÊúÄÂàù„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆË©≥Á¥∞„ÇíÂèñÂæó
                  msg_id = messages[0]['id']
                  message = service.users().messages().get(
                      userId=user_id,
                      id=msg_id
                  ).execute()

                  return message

              except Exception as e:
                  print(f"Error fetching emails: {str(e)}")
                  raise

          def extract_email_content(message):
              headers = message['payload'].get('headers', [])
              subject = next((h['value'] for h in headers if h['name'] == 'Subject'), 'No Subject')
              from_email = next((h['value'] for h in headers if h['name'] == 'From'), 'Unknown Sender')

              body = extract_body(message['payload'])

              return {
                  'id': message['id'],
                  'subject': subject,
                  'from': from_email,
                  'body': body[:500] if body else 'No body content'  # ÊúÄÂàù„ÅÆ500ÊñáÂ≠ó„Åæ„Åß
              }

          def extract_body(payload):
              body = ''

              if 'parts' in payload:
                  for part in payload['parts']:
                      if part['mimeType'] == 'text/plain':
                          data = part['body']['data']
                          body += base64.urlsafe_b64decode(data).decode('utf-8', errors='ignore')
              elif payload['body'].get('data'):
                  body = base64.urlsafe_b64decode(payload['body']['data']).decode('utf-8', errors='ignore')

              return body.strip()

          def send_line_notification(email_content):
              url = 'https://api.line.me/v2/bot/message/push'
              headers = {
                  'Content-Type': 'application/json',
                  'Authorization': f"Bearer {os.environ['LINE_CHANNEL_ACCESS_TOKEN']}"
              }

              message_text = f"üìß Êñ∞ÁùÄ„É°„Éº„É´ (fts„É©„Éô„É´)\n\n"
              message_text += f"‰ª∂Âêç: {email_content['subject']}\n"
              message_text += f"Â∑ÆÂá∫‰∫∫: {email_content['from']}\n\n"
              message_text += f"Êú¨Êñá:\n{email_content['body']}"

              data = {
                  'to': os.environ['LINE_USER_ID'],
                  'messages': [
                      {
                          'type': 'text',
                          'text': message_text
                      }
                  ]
              }

              response = requests.post(url, headers=headers, json=data)
              response.raise_for_status()
              print(f"LINE notification sent successfully for email: {email_content['id']}")

          def mark_as_read(service, msg_id, user_id='me'):
              try:
                  service.users().messages().modify(
                      userId=user_id,
                      id=msg_id,
                      body={'removeLabelIds': ['UNREAD']}
                  ).execute()
                  print(f"Email {msg_id} marked as read")
              except Exception as e:
                  print(f"Error marking email as read: {str(e)}")

          # „É°„Ç§„É≥Âá¶ÁêÜ
          try:
              service = get_gmail_service()
              message = get_unread_fts_emails(service)

              if message:
                  email_content = extract_email_content(message)
                  send_line_notification(email_content)
                  mark_as_read(service, email_content['id'])
                  with open(os.environ.get('GITHUB_OUTPUT', '/dev/null'), 'a') as f:
                      f.write('status=success\n')
              else:
                  print("No new emails to process")
                  with open(os.environ.get('GITHUB_OUTPUT', '/dev/null'), 'a') as f:
                      f.write('status=no_emails\n')

          except Exception as e:
              print(f"Error in main process: {str(e)}")
              with open(os.environ.get('GITHUB_OUTPUT', '/dev/null'), 'a') as f:
                  f.write('status=failed\n')
              raise
          EOF

      - name: Notify to Slack on failure
        if: failure()
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL_ID: ${{ secrets.SLACK_CHANNEL_ID }}
        run: |
          python << 'EOF'
          import os
          import requests
          import json

          def send_slack_notification(message):
              url = 'https://slack.com/api/chat.postMessage'
              headers = {
                  'Content-Type': 'application/json',
                  'Authorization': f"Bearer {os.environ['SLACK_BOT_TOKEN']}"
              }

              data = {
                  'channel': os.environ['SLACK_CHANNEL_ID'],
                  'text': f"‚ö†Ô∏è Gmail to LINE Notification Failed\n\n{message}",
                  'mrkdwn': True
              }

              response = requests.post(url, headers=headers, json=data)
              response_data = response.json()

              if not response_data.get('ok'):
                  print(f"Failed to send Slack notification: {response_data.get('error')}")
              else:
                  print("Slack notification sent successfully")

          # „Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊßãÁØâ
          workflow_url = f"https://github.com/{os.environ.get('GITHUB_REPOSITORY', '')}/actions/runs/{os.environ.get('GITHUB_RUN_ID', '')}"
          error_message = f"Workflow failed: {workflow_url}\nPlease check the logs for details."

          send_slack_notification(error_message)
          EOF
